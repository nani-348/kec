{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///Users/hrishi/Desktop/KADACO/src/lib/sheets.ts"],"sourcesContent":["import { google } from 'googleapis';\n\n// Ensure environment variables are available\nconst SPREADSHEET_ID = process.env.GOOGLE_SHEETS_SPREADSHEET_ID;\nconst CLIENT_EMAIL = process.env.GOOGLE_SHEETS_CLIENT_EMAIL;\nconst PRIVATE_KEY = process.env.GOOGLE_SHEETS_PRIVATE_KEY?.replace(/\\\\n/g, '\\n');\n\nif (!CLIENT_EMAIL || !PRIVATE_KEY) {\n    console.warn('Google Sheets credentials not configured. Using mock data.');\n}\n\n// Initialize auth once\nconst auth = CLIENT_EMAIL && PRIVATE_KEY ? new google.auth.GoogleAuth({\n    credentials: {\n        client_email: CLIENT_EMAIL,\n        private_key: PRIVATE_KEY,\n    },\n    scopes: ['https://www.googleapis.com/auth/spreadsheets.readonly'],\n}) : null;\n\nconst sheets = auth ? google.sheets({ version: 'v4', auth }) : null;\n\n// ============================================================\n// 11 CATEGORY SHEETS\n// ============================================================\n\nexport const CATEGORY_SHEETS = [\n    'Overview',\n    'Groundwater',\n    'Aquifer',\n    'MITanks',\n    'WaterBalance',\n    'Hydrology',\n    'Agriculture',\n    'Conservation',\n    'DataMethods',\n    'Resources',\n    'CaseStudies',\n] as const;\n\nexport type CategorySheet = typeof CATEGORY_SHEETS[number];\n\n// Table metadata - maps table titles to their row ranges within each category sheet\n// Format: { title: string, startRow: number, endRow: number }\nexport interface TableInfo {\n    title: string;\n    headers: string[];\n    startRow: number;\n    rowCount: number;\n}\n\n/**\n * Fetches all data from a category sheet\n * Returns raw 2D array - caller can parse tables using section headers\n */\nexport async function getCategoryData(\n    categoryName: CategorySheet\n): Promise<(string | number | boolean | null)[][]> {\n    if (!sheets || !SPREADSHEET_ID) {\n        console.warn(`Sheet data not available for ${categoryName}. Using fallback.`);\n        return [];\n    }\n\n    try {\n        const response = await sheets.spreadsheets.values.get({\n            spreadsheetId: SPREADSHEET_ID,\n            range: categoryName,\n        });\n\n        return (response.data.values || []) as (string | number | boolean | null)[][];\n    } catch (error) {\n        console.error(`Error fetching category ${categoryName}:`, error);\n        throw error;\n    }\n}\n\n/**\n * Parses a category sheet into individual tables\n * Tables are separated by blank rows, with title row followed by header row\n */\nexport function parseTables(\n    rawData: (string | number | boolean | null)[][]\n): Map<string, Record<string, unknown>[]> {\n    const tables = new Map<string, Record<string, unknown>[]>();\n\n    let currentTitle = '';\n    let currentHeaders: string[] = [];\n    let currentRows: Record<string, unknown>[] = [];\n    let expectingHeaders = false;\n\n    for (const row of rawData) {\n        // Empty row - save current table and reset\n        if (!row || row.length === 0 || row.every(cell => cell === null || cell === '')) {\n            if (currentTitle && currentRows.length > 0) {\n                tables.set(currentTitle, currentRows);\n            }\n            currentTitle = '';\n            currentHeaders = [];\n            currentRows = [];\n            expectingHeaders = false;\n            continue;\n        }\n\n        // Check if this is a title row (starts with emoji or all caps first cell)\n        const firstCell = String(row[0] || '');\n        const isTitle = firstCell.match(/^[ðŸ“ŠðŸŒ§ï¸ðŸ“‹ðŸ“ˆðŸ—ºï¸ðŸŒŠâ¬†ï¸â¬‡ï¸âš–ï¸ðŸš°ðŸ’§ðŸ”¬âš ï¸ðŸ—ï¸ðŸ’¡ðŸŒ¾ðŸ”§âš¡ðŸ”„ðŸ“ðŸŒ¾]/);\n\n        if (isTitle) {\n            // Save previous table if exists\n            if (currentTitle && currentRows.length > 0) {\n                tables.set(currentTitle, currentRows);\n            }\n            currentTitle = firstCell;\n            currentHeaders = [];\n            currentRows = [];\n            expectingHeaders = true;\n            continue;\n        }\n\n        // If expecting headers, this row is the header row\n        if (expectingHeaders) {\n            currentHeaders = row.map(cell => String(cell || ''));\n            expectingHeaders = false;\n            continue;\n        }\n\n        // Data row - convert to object using headers\n        if (currentHeaders.length > 0) {\n            const obj: Record<string, unknown> = {};\n            currentHeaders.forEach((header, index) => {\n                const value = row[index];\n                if (value === '' || value === undefined || value === null) {\n                    obj[header] = null;\n                } else if (value === 'true' || value === 'TRUE') {\n                    obj[header] = true;\n                } else if (value === 'false' || value === 'FALSE') {\n                    obj[header] = false;\n                } else {\n                    const numValue = parseFloat(String(value));\n                    obj[header] = !isNaN(numValue) && String(numValue) === String(value) ? numValue : value;\n                }\n            });\n            currentRows.push(obj);\n        }\n    }\n\n    // Don't forget the last table\n    if (currentTitle && currentRows.length > 0) {\n        tables.set(currentTitle, currentRows);\n    }\n\n    return tables;\n}\n\n/**\n * Get a specific table from a category by its title (or partial match)\n */\nexport async function getTableData<T = Record<string, unknown>>(\n    categoryName: CategorySheet,\n    tableTitle: string\n): Promise<T[]> {\n    const rawData = await getCategoryData(categoryName);\n    const tables = parseTables(rawData);\n\n    // Find table by partial title match\n    for (const [title, data] of tables) {\n        if (title.toLowerCase().includes(tableTitle.toLowerCase())) {\n            return data as T[];\n        }\n    }\n\n    console.warn(`Table \"${tableTitle}\" not found in ${categoryName}`);\n    return [];\n}\n\n/**\n * Get all tables from a category\n */\nexport async function getAllTables(\n    categoryName: CategorySheet\n): Promise<Map<string, Record<string, unknown>[]>> {\n    const rawData = await getCategoryData(categoryName);\n    return parseTables(rawData);\n}\n\n// ============================================================\n// CONVENIENCE FUNCTIONS FOR COMMON DATA\n// ============================================================\n\n// Groundwater\nexport async function getRealTimeWaterData() {\n    return getTableData('Groundwater', 'REAL-TIME WATER LEVELS');\n}\n\nexport async function getSeasonalFluctuationData() {\n    return getTableData('Groundwater', 'SEASONAL FLUCTUATION');\n}\n\nexport async function getYearComparisonData() {\n    return getTableData('Groundwater', 'YEAR-OVER-YEAR');\n}\n\n// Overview\nexport async function getRainfallData() {\n    return getTableData('Overview', 'RAINFALL BY MANDAL');\n}\n\nexport async function getSeasonalRainfallData() {\n    return getTableData('Overview', 'SEASONAL RAINFALL');\n}\n\n// Aquifer\nexport async function getAquiferParameters() {\n    return getTableData('Aquifer', 'AQUIFER PARAMETERS');\n}\n\nexport async function getSustainabilityData() {\n    return getTableData('Aquifer', 'SUSTAINABILITY');\n}\n\n// MI Tanks\nexport async function getTankInventory() {\n    return getTableData('MITanks', 'TANK INVENTORY');\n}\n\nexport async function getTankStorageStatus() {\n    return getTableData('MITanks', 'CURRENT STORAGE STATUS');\n}\n\n// Water Balance\nexport async function getInflowsData() {\n    return getTableData('WaterBalance', 'INFLOWS');\n}\n\nexport async function getOutflowsData() {\n    return getTableData('WaterBalance', 'OUTFLOWS');\n}\n\n// Conservation\nexport async function getConservationMetrics() {\n    return getTableData('Conservation', 'SUMMARY METRICS');\n}\n\nexport async function getStructureDistribution() {\n    return getTableData('Conservation', 'STRUCTURE DISTRIBUTION');\n}\n\n// Agriculture\nexport async function getCropData() {\n    return getTableData('Agriculture', 'CROP AREA');\n}\n\nexport async function getIrrigationMethods() {\n    return getTableData('Agriculture', 'IRRIGATION METHODS');\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAEA,6CAA6C;AAC7C,MAAM,iBAAiB,QAAQ,GAAG,CAAC,4BAA4B;AAC/D,MAAM,eAAe,QAAQ,GAAG,CAAC,0BAA0B;AAC3D,MAAM,cAAc,QAAQ,GAAG,CAAC,yBAAyB,EAAE,QAAQ,QAAQ;AAE3E,IAAI,CAAC,gBAAgB,CAAC,aAAa;IAC/B,QAAQ,IAAI,CAAC;AACjB;AAEA,uBAAuB;AACvB,MAAM,OAAO,gBAAgB,cAAc,IAAI,oLAAM,CAAC,IAAI,CAAC,UAAU,CAAC;IAClE,aAAa;QACT,cAAc;QACd,aAAa;IACjB;IACA,QAAQ;QAAC;KAAwD;AACrE,KAAK;AAEL,MAAM,SAAS,OAAO,oLAAM,CAAC,MAAM,CAAC;IAAE,SAAS;IAAM;AAAK,KAAK;AAMxD,MAAM,kBAAkB;IAC3B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACH;AAiBM,eAAe,gBAClB,YAA2B;IAE3B,IAAI,CAAC,UAAU,CAAC,gBAAgB;QAC5B,QAAQ,IAAI,CAAC,CAAC,6BAA6B,EAAE,aAAa,iBAAiB,CAAC;QAC5E,OAAO,EAAE;IACb;IAEA,IAAI;QACA,MAAM,WAAW,MAAM,OAAO,YAAY,CAAC,MAAM,CAAC,GAAG,CAAC;YAClD,eAAe;YACf,OAAO;QACX;QAEA,OAAQ,SAAS,IAAI,CAAC,MAAM,IAAI,EAAE;IACtC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,CAAC,wBAAwB,EAAE,aAAa,CAAC,CAAC,EAAE;QAC1D,MAAM;IACV;AACJ;AAMO,SAAS,YACZ,OAA+C;IAE/C,MAAM,SAAS,IAAI;IAEnB,IAAI,eAAe;IACnB,IAAI,iBAA2B,EAAE;IACjC,IAAI,cAAyC,EAAE;IAC/C,IAAI,mBAAmB;IAEvB,KAAK,MAAM,OAAO,QAAS;QACvB,2CAA2C;QAC3C,IAAI,CAAC,OAAO,IAAI,MAAM,KAAK,KAAK,IAAI,KAAK,CAAC,CAAA,OAAQ,SAAS,QAAQ,SAAS,KAAK;YAC7E,IAAI,gBAAgB,YAAY,MAAM,GAAG,GAAG;gBACxC,OAAO,GAAG,CAAC,cAAc;YAC7B;YACA,eAAe;YACf,iBAAiB,EAAE;YACnB,cAAc,EAAE;YAChB,mBAAmB;YACnB;QACJ;QAEA,0EAA0E;QAC1E,MAAM,YAAY,OAAO,GAAG,CAAC,EAAE,IAAI;QACnC,MAAM,UAAU,UAAU,KAAK,CAAC;QAEhC,IAAI,SAAS;YACT,gCAAgC;YAChC,IAAI,gBAAgB,YAAY,MAAM,GAAG,GAAG;gBACxC,OAAO,GAAG,CAAC,cAAc;YAC7B;YACA,eAAe;YACf,iBAAiB,EAAE;YACnB,cAAc,EAAE;YAChB,mBAAmB;YACnB;QACJ;QAEA,mDAAmD;QACnD,IAAI,kBAAkB;YAClB,iBAAiB,IAAI,GAAG,CAAC,CAAA,OAAQ,OAAO,QAAQ;YAChD,mBAAmB;YACnB;QACJ;QAEA,6CAA6C;QAC7C,IAAI,eAAe,MAAM,GAAG,GAAG;YAC3B,MAAM,MAA+B,CAAC;YACtC,eAAe,OAAO,CAAC,CAAC,QAAQ;gBAC5B,MAAM,QAAQ,GAAG,CAAC,MAAM;gBACxB,IAAI,UAAU,MAAM,UAAU,aAAa,UAAU,MAAM;oBACvD,GAAG,CAAC,OAAO,GAAG;gBAClB,OAAO,IAAI,UAAU,UAAU,UAAU,QAAQ;oBAC7C,GAAG,CAAC,OAAO,GAAG;gBAClB,OAAO,IAAI,UAAU,WAAW,UAAU,SAAS;oBAC/C,GAAG,CAAC,OAAO,GAAG;gBAClB,OAAO;oBACH,MAAM,WAAW,WAAW,OAAO;oBACnC,GAAG,CAAC,OAAO,GAAG,CAAC,MAAM,aAAa,OAAO,cAAc,OAAO,SAAS,WAAW;gBACtF;YACJ;YACA,YAAY,IAAI,CAAC;QACrB;IACJ;IAEA,8BAA8B;IAC9B,IAAI,gBAAgB,YAAY,MAAM,GAAG,GAAG;QACxC,OAAO,GAAG,CAAC,cAAc;IAC7B;IAEA,OAAO;AACX;AAKO,eAAe,aAClB,YAA2B,EAC3B,UAAkB;IAElB,MAAM,UAAU,MAAM,gBAAgB;IACtC,MAAM,SAAS,YAAY;IAE3B,oCAAoC;IACpC,KAAK,MAAM,CAAC,OAAO,KAAK,IAAI,OAAQ;QAChC,IAAI,MAAM,WAAW,GAAG,QAAQ,CAAC,WAAW,WAAW,KAAK;YACxD,OAAO;QACX;IACJ;IAEA,QAAQ,IAAI,CAAC,CAAC,OAAO,EAAE,WAAW,eAAe,EAAE,cAAc;IACjE,OAAO,EAAE;AACb;AAKO,eAAe,aAClB,YAA2B;IAE3B,MAAM,UAAU,MAAM,gBAAgB;IACtC,OAAO,YAAY;AACvB;AAOO,eAAe;IAClB,OAAO,aAAa,eAAe;AACvC;AAEO,eAAe;IAClB,OAAO,aAAa,eAAe;AACvC;AAEO,eAAe;IAClB,OAAO,aAAa,eAAe;AACvC;AAGO,eAAe;IAClB,OAAO,aAAa,YAAY;AACpC;AAEO,eAAe;IAClB,OAAO,aAAa,YAAY;AACpC;AAGO,eAAe;IAClB,OAAO,aAAa,WAAW;AACnC;AAEO,eAAe;IAClB,OAAO,aAAa,WAAW;AACnC;AAGO,eAAe;IAClB,OAAO,aAAa,WAAW;AACnC;AAEO,eAAe;IAClB,OAAO,aAAa,WAAW;AACnC;AAGO,eAAe;IAClB,OAAO,aAAa,gBAAgB;AACxC;AAEO,eAAe;IAClB,OAAO,aAAa,gBAAgB;AACxC;AAGO,eAAe;IAClB,OAAO,aAAa,gBAAgB;AACxC;AAEO,eAAe;IAClB,OAAO,aAAa,gBAAgB;AACxC;AAGO,eAAe;IAClB,OAAO,aAAa,eAAe;AACvC;AAEO,eAAe;IAClB,OAAO,aAAa,eAAe;AACvC"}},
    {"offset": {"line": 358, "column": 0}, "map": {"version":3,"sources":["file:///Users/hrishi/Desktop/KADACO/src/app/api/sheets/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport {\n    getCategoryData,\n    parseTables,\n    getTableData,\n    CATEGORY_SHEETS\n} from '@/lib/sheets';\n\nexport const dynamic = 'force-dynamic'; // Disable caching for real-time data\n\ntype SheetCategory = (typeof CATEGORY_SHEETS)[number];\n\nconst isSheetCategory = (value: string): value is SheetCategory =>\n    CATEGORY_SHEETS.includes(value as SheetCategory);\n\nexport async function GET(request: NextRequest) {\n    try {\n        const searchParams = request.nextUrl.searchParams;\n        const category = searchParams.get('category');\n        const table = searchParams.get('table');\n\n        // Validate category\n        if (!category) {\n            return NextResponse.json(\n                {\n                    error: 'Missing required parameter: category',\n                    availableCategories: CATEGORY_SHEETS,\n                    usage: '/api/sheets?category=Groundwater&table=REAL-TIME'\n                },\n                { status: 400 }\n            );\n        }\n\n        // Check if category is valid\n        if (!isSheetCategory(category)) {\n            return NextResponse.json(\n                {\n                    error: `Invalid category: ${category}`,\n                    availableCategories: CATEGORY_SHEETS\n                },\n                { status: 400 }\n            );\n        }\n\n        // If table is specified, return just that table\n        if (table) {\n            const data = await getTableData(category, table);\n            return NextResponse.json({\n                success: true,\n                category,\n                table,\n                count: data.length,\n                data,\n                lastFetched: new Date().toISOString(),\n            });\n        }\n\n        // Otherwise return all tables in the category\n        const rawData = await getCategoryData(category);\n        const tables = parseTables(rawData);\n\n        // Convert Map to object for JSON\n        const tablesObj: Record<string, unknown[]> = {};\n        for (const [title, data] of tables) {\n            tablesObj[title] = data;\n        }\n\n        return NextResponse.json({\n            success: true,\n            category,\n            tableCount: tables.size,\n            tables: Array.from(tables.keys()),\n            data: tablesObj,\n            lastFetched: new Date().toISOString(),\n        });\n    } catch (error) {\n        console.error('API Error:', error);\n        return NextResponse.json(\n            {\n                error: 'Failed to fetch sheet data',\n                message: error instanceof Error ? error.message : 'Unknown error'\n            },\n            { status: 500 }\n        );\n    }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAOO,MAAM,UAAU,iBAAiB,qCAAqC;AAI7E,MAAM,kBAAkB,CAAC,QACrB,8JAAe,CAAC,QAAQ,CAAC;AAEtB,eAAe,IAAI,OAAoB;IAC1C,IAAI;QACA,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;QACjD,MAAM,WAAW,aAAa,GAAG,CAAC;QAClC,MAAM,QAAQ,aAAa,GAAG,CAAC;QAE/B,oBAAoB;QACpB,IAAI,CAAC,UAAU;YACX,OAAO,qKAAY,CAAC,IAAI,CACpB;gBACI,OAAO;gBACP,qBAAqB,8JAAe;gBACpC,OAAO;YACX,GACA;gBAAE,QAAQ;YAAI;QAEtB;QAEA,6BAA6B;QAC7B,IAAI,CAAC,gBAAgB,WAAW;YAC5B,OAAO,qKAAY,CAAC,IAAI,CACpB;gBACI,OAAO,CAAC,kBAAkB,EAAE,UAAU;gBACtC,qBAAqB,8JAAe;YACxC,GACA;gBAAE,QAAQ;YAAI;QAEtB;QAEA,gDAAgD;QAChD,IAAI,OAAO;YACP,MAAM,OAAO,MAAM,IAAA,2JAAY,EAAC,UAAU;YAC1C,OAAO,qKAAY,CAAC,IAAI,CAAC;gBACrB,SAAS;gBACT;gBACA;gBACA,OAAO,KAAK,MAAM;gBAClB;gBACA,aAAa,IAAI,OAAO,WAAW;YACvC;QACJ;QAEA,8CAA8C;QAC9C,MAAM,UAAU,MAAM,IAAA,8JAAe,EAAC;QACtC,MAAM,SAAS,IAAA,0JAAW,EAAC;QAE3B,iCAAiC;QACjC,MAAM,YAAuC,CAAC;QAC9C,KAAK,MAAM,CAAC,OAAO,KAAK,IAAI,OAAQ;YAChC,SAAS,CAAC,MAAM,GAAG;QACvB;QAEA,OAAO,qKAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT;YACA,YAAY,OAAO,IAAI;YACvB,QAAQ,MAAM,IAAI,CAAC,OAAO,IAAI;YAC9B,MAAM;YACN,aAAa,IAAI,OAAO,WAAW;QACvC;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,cAAc;QAC5B,OAAO,qKAAY,CAAC,IAAI,CACpB;YACI,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QACtD,GACA;YAAE,QAAQ;QAAI;IAEtB;AACJ"}}]
}